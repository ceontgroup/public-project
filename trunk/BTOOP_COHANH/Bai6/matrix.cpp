// Class automatically generated by Dev-C++ New Class wizard

#include "matrix.h" // class's header file


extern template class matrix<T>;
template <class T>
matrix<T>::matrix(int n,int m):n(n),m(m)
{
	assert(n>0 && m>0);
	id++;
	arr=new T[n*m];
	for (int i=0;i<n*m;i++) arr[i]=0;
}

// class destructor
template <class T>
matrix<T>::~matrix()
{
	id--;
	delete []arr;
}
template <class T>
int matrix<T>::id=0;
template <class T>
matrix<T>::matrix<T>(const matrix<T> &obj):n(obj.n),m(obj.m){
	id++;
	arr=new T[n*m];
	for (int i=0;i<n*m;i++) arr[i]=obj[i];
	};
template <class T>	
const matrix<T> matrix<T>::operator=(const matrix<T> &obj){
	if (this==&obj) return *this;
	else 
	if (n!=obj.n || m!=obj.m) cout<<endl<<"Error during execute operator =";
	else
		for (int i=0;i<n*m;i++) arr[i]=obj[i];
	return *this;
	};
template <class T>
T &matrix<T>::operator[](int p)const{
	if (p>=0 && p<n*m) return arr[p];
	};
template <class T>
T &matrix<T>::operator()(int i,int j)const{
	if (i*m+j>=0 && i*m+j<n*m) return arr[i*m+j];
	};
template <class S>	
istream &operator>>(istream &is,matrix<S> &obj){
	for (int i=0;i<obj.n*obj.m;i++){
		cout<<"arr["<<row(i,obj.m)<<","<<col(i,obj.m)<<"]="; 
		is>>obj.arr[i];
		}
	return is;
	};
template <class S>
ostream &operator<<(ostream &os,const matrix<S> &obj){
	for (int i=0;i<obj.n*obj.m;i++){
		if(i%obj.m==0) os<<endl;		
		os<<setw(4)<<obj.arr[i];
		}
	return os;
	};
template <class T>
matrix<T> matrix<T>::operator+(const matrix<T> &obj) const{
	if (obj.n!=n && obj.m!=m) cout<<endl<<"Error during execute operator +";
	else{
		matrix<T> tem(n,m);
		for (int i=0;i<n*m;i++) tem[i]=arr[i]+obj[i];
		return tem;
		}
	return *this;	
	};		
template <class T>
matrix<T> matrix<T>::operator-(const matrix<T> &obj) const{
	if (obj.n!=n && obj.m!=m) cout<<endl<<"Error during execute operator -";
	else{
		matrix<T> tem(n,m);
		for (int i=0;i<n*m;i++) tem[i]=arr[i]- obj[i];
		return tem;
		}
	return *this;	
	};
template <class T>
matrix<T> matrix<T>::operator*(T k) const{
	matrix<T> tem(n,m);
	for (int i=0;i<n*m;i++) tem[i]=k*arr[i];
	return tem;
	};
	
template <class R, class S>
matrix<R> operator*(S k,const matrix<R> &obj){
	matrix<R> tem(obj.n,obj.m);
	for (int i=0;i<obj.n*obj.m;i++) tem[i]=R(k)*obj[i];
	return tem;
	};
/*	
template <class T>
matrix<T> operator*(T k,const matrix<T> &obj){
	matrix<T> tem(obj.n,obj.m);
	for (int i=0;i<obj.n*obj.m;i++) tem[i]=T(k)*obj[i];
	return tem;
	};*/
	
template <class T>
matrix<T> matrix<T>::operator*(const matrix<T> &obj) const{
	if (m!=obj.n) cout<<endl<<"Error during execute operator * between two matrix<T>";
	else{
		matrix<T> tem(n,obj.m);
		for(int i=0;i<tem.n;i++)
			for(int j=0;j<tem.m;j++)
				for(int k=0;k<m;k++)
					tem(i,j)+= arr[i*m+k]*obj(k,j);
		return tem;
		}
	return *this;	
	};
